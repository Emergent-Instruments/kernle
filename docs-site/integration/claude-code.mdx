---
title: Claude Code
description: "Hook-based automatic memory for Claude Code sessions"
---

# Claude Code Integration

Kernle integrates with Claude Code via a **SessionStart hook** — memory loads automatically when you start a session. No manual `kernle load` needed.

## How It Works

```
CLAUDE CODE SESSION STARTS
       ↓
1. SessionStart hook fires
2. Hook executes: `kernle -s {stackId} load`
3. Output added to session context automatically
4. SI has full memory: values, beliefs, goals, checkpoint, episodes
       ↓
   SI WORKS (captures memories via CLI as they happen)
       ↓
SESSION ENDS
       ↓
5. SI saves checkpoint before ending (manual — no auto-save hook)
```

<Note>
The SI never needs to run `kernle load` manually. The SessionStart hook handles it automatically. However, unlike OpenClaw, Claude Code does not have a pre-compaction auto-save mechanism — the SI must save checkpoints explicitly.
</Note>

## Installation

<Steps>
  <Step title="Install Kernle">
    ```bash
    pip install kernle
    # or
    pipx install kernle
    ```
  </Step>
  <Step title="Initialize a Stack">
    ```bash
    kernle -s my-project init
    ```
  </Step>
  <Step title="Run Setup">
    Install the SessionStart hook:
    ```bash
    # Project-level (recommended)
    kernle -s my-project setup claude-code

    # Or global (all Claude Code sessions)
    kernle -s my-project setup claude-code --global
    ```
    This adds a `SessionStart` hook to `.claude/settings.json` (project) or `~/.claude/settings.json` (global) that runs `kernle load` automatically.
  </Step>
  <Step title="Verify">
    Start a new Claude Code session:
    ```bash
    claude
    ```
    Ask: *"What are my current values and goals from Kernle?"*

    The SI should respond with your memory without needing to run any commands.
  </Step>
</Steps>

## What the Hook Does

The setup command adds this to your `.claude/settings.json`:

```json
{
  "hooks": {
    "SessionStart": [
      {
        "name": "kernle-memory-load",
        "description": "Automatically load Kernle persistent memory at session start",
        "hooks": [
          {
            "type": "command",
            "command": "bash -c 'kernle -s my-project load 2>/dev/null || echo \"# Kernle Memory\\n\\nKernle not available in this session.\"'"
          }
        ]
      }
    ]
  }
}
```

If you already have a `.claude/settings.json`, the setup command merges the hook into your existing configuration without overwriting other settings.

### Graceful Degradation

If Kernle is not installed, the stack doesn't exist, or the command fails, the hook outputs a fallback message and the session continues normally.

## What Gets Loaded

The hook runs `kernle -s {stackId} load` and the output is added to the session context containing:

- **Checkpoint** — current task, context, next steps (resume point)
- **Values** — core principles
- **Beliefs** — held truths with confidence levels
- **Goals** — active goals with priority
- **Drives** — motivations with intensity
- **Lessons** — extracted from recent episodes
- **Relationships** — key entities with sentiment

Memory loading is budget-aware by default (8000 tokens). Items are loaded by priority: checkpoint > values > beliefs > goals > drives > episodes > notes > relationships.

## During Work

The SI captures memories via CLI as they happen. Each command writes immediately to local storage:

```bash
# Quick capture
kernle -s my-project raw "API rate limit is per-user, not per-key"

# Record a significant experience
kernle -s my-project episode "Debugged API timeout" "success" \
  --lesson "Check network latency before assuming code issues"

# Document a decision
kernle -s my-project note "Using Redis for session cache" \
  --type decision \
  --reason "Need sub-millisecond reads"
```

## Saving State

Claude Code does not have an automatic pre-compaction save mechanism like OpenClaw's `memoryFlush`. The SI must save checkpoints explicitly.

Add checkpoint instructions to your project's `CLAUDE.md`:

```markdown
## Memory

Before ending a session or when context pressure builds:
```
kernle -s my-project checkpoint save "<specific task>" --context "<progress>"
```

Be specific:
- Bad: "Saving state"
- Good: "Building auth API - finished /login, next: add JWT refresh"
```

### When to Checkpoint

| Situation | Action |
|-----------|--------|
| Before ending session | Save checkpoint with current task |
| Before large context operations | Save checkpoint as safety net |
| After completing a major task | Save checkpoint with summary |
| Context getting large | Save checkpoint proactively |

## Relationship to Native Features

Claude Code has its own memory mechanisms. Here's how they interact with Kernle:

| Feature | What It Does | Kernle Relationship |
|---------|-------------|-------------------|
| `CLAUDE.md` | Static project instructions | **Coexists** — different purpose (instructions vs memory) |
| Auto-memory (`~/.claude/.../memory/`) | Simple text notes across sessions | **Replaced** — Kernle provides typed, structured memory with provenance |
| Conversation context | In-session history | **Coexists** — Kernle adds cross-session persistence |

<Note>
`CLAUDE.md` is not replaced by Kernle. It serves as the project instruction file — where you put setup commands, coding guidelines, and workflow rules. Kernle handles dynamic memory (what the SI has experienced, learned, and believes).
</Note>

## MCP Server (Alternative)

Kernle also provides an MCP server that works with Claude Code. This is an alternative to the hook approach — use one or the other, not both.

The hook approach is recommended because:
- Memory loads automatically (no manual tool call needed)
- Simpler setup
- No MCP configuration required

If you need MCP tools during the session (e.g., `memory_search`, `memory_anxiety`), you can use both: the hook for automatic loading, and MCP for in-session memory operations. See the [MCP Integration](/integration/mcp) guide.

## Dynamic Stack Detection

For multi-project setups, use environment variables:

```json
{
  "hooks": {
    "SessionStart": [
      {
        "hooks": [
          {
            "type": "command",
            "command": "bash -c 'kernle -s ${KERNLE_STACK_ID:-main} load 2>/dev/null || true'"
          }
        ]
      }
    ]
  }
}
```

Set `KERNLE_STACK_ID` in your shell profile:

```bash
export KERNLE_STACK_ID=my-project
```

## Diagnostics

Verify the hook is configured:

```bash
# Check hook status
kernle -s my-project doctor --full

# Test manually
kernle -s my-project load
```

## Troubleshooting

### Memory not appearing at session start

1. Check the hook is installed:
   ```bash
   cat .claude/settings.json | grep -A 10 kernle
   # or
   cat ~/.claude/settings.json | grep -A 10 kernle
   ```

2. Verify valid JSON:
   ```bash
   jq . .claude/settings.json
   ```

3. Test the command manually:
   ```bash
   kernle -s my-project load
   ```

4. Check if stack is initialized:
   ```bash
   kernle -s my-project status
   ```

### Kernle command not found

Ensure Kernle is installed and in PATH:

```bash
which kernle
# If missing:
pip install kernle
```

### Hook not merging with existing settings

Use `--force` to overwrite:

```bash
kernle -s my-project setup claude-code --force
```

## Cowork

Cowork uses the same `.claude/settings.json` format. The setup command works identically:

```bash
kernle -s my-project setup cowork
```
