---
title: Claude Code
description: "Plugin-based automatic memory for Claude Code sessions"
---

# Claude Code Integration

Kernle integrates with Claude Code via a **plugin** — memory loads automatically, checkpoints save before compaction and at session end, and native memory file writes are intercepted and captured into Kernle.

## How It Works

```
CLAUDE CODE SESSION STARTS
       ↓
1. SessionStart hook fires
2. Plugin runs: `kernle -s {stackId} load --budget {budget}`
3. Memory injected as session context automatically
4. SI has full memory: values, beliefs, goals, checkpoint, episodes
       ↓
   SI WORKS (captures memories via CLI as they happen)
       ↓
   CONTEXT COMPACTION
       ↓
5. PreCompact hook saves checkpoint automatically
6. SessionStart re-fires — memory reloaded into fresh context
       ↓
   SI CONTINUES WORKING
       ↓
SESSION ENDS
       ↓
7. SessionEnd hook saves final checkpoint automatically
```

### Write Interception

When the SI tries to write to `memory/` or `MEMORY.md` (Claude Code's native memory), the plugin:

1. Captures the content as a Kernle raw entry
2. Blocks the write
3. Returns a message directing the SI to use Kernle commands instead

This ensures all memory flows through Kernle's structured system.

<Note>
Unlike the previous hook-based approach, this plugin provides full lifecycle coverage — automatic loading, pre-compaction checkpointing, session-end checkpointing, and write interception. No manual checkpoint saves needed.
</Note>

## Installation

<Steps>
  <Step title="Install Kernle">
    ```bash
    pip install kernle
    # or
    pipx install kernle
    ```
  </Step>
  <Step title="Initialize a Stack">
    ```bash
    kernle -s my-project init
    ```
  </Step>
  <Step title="Run with Plugin">
    ```bash
    claude --plugin-dir ./integrations/claude-code
    ```
    The plugin directory is inside the Kernle repo at `integrations/claude-code/`.
  </Step>
  <Step title="Verify">
    Start a new Claude Code session with the plugin:
    ```bash
    claude --plugin-dir ./integrations/claude-code
    ```
    Ask: *"What are my current values and goals from Kernle?"*

    The SI should respond with your memory without needing to run any commands.
  </Step>
</Steps>

## Configuration

All configuration is via environment variables — no config files needed:

| Variable | Default | Description |
|----------|---------|-------------|
| `KERNLE_STACK_ID` | auto-detected | Kernle stack ID |
| `KERNLE_BIN` | `kernle` | Path to kernle binary |
| `KERNLE_TIMEOUT` | `5` | CLI timeout in seconds |
| `KERNLE_TOKEN_BUDGET` | `8000` | Token budget for memory loading |

### Stack ID Resolution

The plugin resolves the stack ID in order:

1. `KERNLE_STACK_ID` environment variable
2. Project directory name from working directory
3. Kernle auto-resolve (omits `-s` flag, lets kernle decide)

For multi-project setups, set `KERNLE_STACK_ID` in your shell profile:

```bash
export KERNLE_STACK_ID=my-project
```

## Plugin Hooks

### SessionStart — Memory Loading

Fires on startup, resume, clear, and compact. Runs `kernle load` and injects the output as `additionalContext` in the session.

### PreToolUse — Write Interception

Matches `Write`, `Edit`, and `NotebookEdit` tool calls. When the target path matches a memory file (`memory/`, `MEMORY.md`), the plugin:

- Captures the content as a Kernle raw entry (for preservation)
- Blocks the write with a deny decision
- Returns a message explaining that memory is handled by Kernle

### PreCompact — Pre-Compaction Checkpoint

Fires before context compaction. Reads the transcript to extract the last user message (task) and assistant message (context), then saves a checkpoint prefixed with `[pre-compact]`.

### SessionEnd — Final Checkpoint

Fires when the session terminates. Reads the transcript and saves both a checkpoint and a raw entry marking session completion.

### Graceful Degradation

All hooks exit 0 on any error. If Kernle is not installed, the stack doesn't exist, or any command fails, the session continues normally with no error messages.

## What Gets Loaded

The plugin runs `kernle load` and the output is injected into the session context containing:

- **Checkpoint** — current task, context, next steps (resume point)
- **Values** — core principles
- **Beliefs** — held truths with confidence levels
- **Goals** — active goals with priority
- **Drives** — motivations with intensity
- **Lessons** — extracted from recent episodes
- **Relationships** — key entities with sentiment

Memory loading is budget-aware (default 8000 tokens). Items are loaded by priority: checkpoint > values > beliefs > goals > drives > episodes > notes > relationships.

## During Work

The SI captures memories via CLI as they happen. Each command writes immediately to local storage:

```bash
# Quick capture
kernle -s my-project raw "API rate limit is per-user, not per-key"

# Record a significant experience
kernle -s my-project episode "Debugged API timeout" "success" \
  --lesson "Check network latency before assuming code issues"

# Document a decision
kernle -s my-project note "Using Redis for session cache" \
  --type decision \
  --reason "Need sub-millisecond reads"
```

## Relationship to Native Features

Claude Code has its own memory mechanisms. Here's how they interact with Kernle:

| Feature | What It Does | Kernle Relationship |
|---------|-------------|-------------------|
| `CLAUDE.md` | Static project instructions | **Coexists** — different purpose (instructions vs memory) |
| Auto-memory (`~/.claude/.../memory/`) | Simple text notes across sessions | **Replaced** — plugin intercepts writes and routes to Kernle |
| Conversation context | In-session history | **Coexists** — Kernle adds cross-session persistence |

<Note>
`CLAUDE.md` is not replaced by Kernle. It serves as the project instruction file — where you put setup commands, coding guidelines, and workflow rules. Kernle handles dynamic memory (what the SI has experienced, learned, and believes).
</Note>

## MCP Server (Alternative)

Kernle also provides an MCP server that works with Claude Code. This is an alternative to the plugin approach — use one or the other for memory loading, not both.

The plugin approach is recommended because:
- Memory loads automatically (no manual tool call needed)
- Auto-checkpointing before compaction and at session end
- Native write interception routes all memory through Kernle
- No MCP configuration required

If you need MCP tools during the session (e.g., `memory_search`, `memory_anxiety`), you can use both: the plugin for automatic lifecycle management, and MCP for in-session memory operations. See the [MCP Integration](/integration/mcp) guide.

## Diagnostics

Verify the plugin works:

```bash
# Test with plugin
claude --plugin-dir ./integrations/claude-code

# Verify Kernle is available
which kernle
kernle -s my-project status

# Test loading manually
kernle -s my-project load
```

## Troubleshooting

### Memory not appearing at session start

1. Verify you're using the `--plugin-dir` flag:
   ```bash
   claude --plugin-dir ./integrations/claude-code
   ```

2. Check that the plugin manifest exists:
   ```bash
   cat integrations/claude-code/.claude-plugin/plugin.json
   ```

3. Test the load command manually:
   ```bash
   kernle -s my-project load
   ```

4. Check if stack is initialized:
   ```bash
   kernle -s my-project status
   ```

### Kernle command not found

Ensure Kernle is installed and in PATH:

```bash
which kernle
# If missing:
pip install kernle
```

### Writes to MEMORY.md being blocked

This is expected behavior. The plugin intercepts writes to memory files and routes them through Kernle. Use Kernle CLI commands instead:

```bash
kernle -s my-project raw "your thought here"
kernle -s my-project note "your observation" --type insight
```
