---
title: "Choosing an Integration"
description: "When to use OpenClaw plugin vs Claude Code hooks"
---

# Choosing an Integration

Kernle ships two integration paths for automatic memory management. Both provide the same core lifecycle — load at start, checkpoint at end, write interception — but they differ in platform, setup, and extensibility.

## Quick Decision

| If you use... | Use this integration |
|--------------|---------------------|
| **Claude Code** (CLI `claude`) | [Claude Code hooks](/integration/claude-code) |
| **OpenClaw** | [OpenClaw plugin](/integration/openclaw) |
| **Claude Desktop** or other MCP clients | [MCP server](/integration/mcp) (manual lifecycle) |

If you use **both** Claude Code and OpenClaw for the same SI, pick one for automatic lifecycle and use the other with manual commands only. Running both auto-lifecycle integrations on the same stack will cause duplicate checkpoints.

## Feature Comparison

| Feature | Claude Code Hooks | OpenClaw Plugin |
|---------|------------------|-----------------|
| **Setup** | `kernle setup claude-code` | `openclaw plugins install` |
| **Config format** | `.claude/settings.json` | OpenClaw plugin config |
| **Memory loading** | SessionStart hook | `before_agent_start` hook |
| **Auto-checkpoint** | PreCompact + SessionEnd | `agent_end` hook |
| **Write interception** | PreToolUse (Write/Edit/NotebookEdit) | `before_tool_call` (write_file/edit_file/create_file) |
| **Compaction awareness** | Yes — saves checkpoint before context compaction | No — OpenClaw doesn't expose compaction events |
| **Stack ID resolution** | Env var, `--stack` flag, or directory name | Plugin config, env var, session key, or directory name |
| **Global vs project** | Both (`--global` flag) | Per-workspace |
| **MCP tools alongside** | Yes — use hooks for lifecycle, MCP for in-session tools | Yes — same approach |
| **Transcript access** | PreCompact/SessionEnd read transcript for checkpoint | `agent_end` uses conversation messages |

## Can They Coexist?

**On different machines or projects** — yes, no conflicts.

**On the same project** — avoid running both. Each integration will:
1. Load memory at session start (duplicate load is harmless but wastes tokens)
2. Save a checkpoint at session end (duplicate checkpoint is mostly harmless)
3. Intercept memory file writes (the first hook to fire wins)

If you need to switch:

```bash
# Remove Claude Code hooks
# Delete the kernle-related hooks from .claude/settings.json

# Or remove OpenClaw plugin
openclaw plugins uninstall kernle
```

## When to Use MCP Instead

The MCP server (`kernle mcp`) is not an automatic lifecycle integration — it provides tools that the SI calls on demand (`memory_search`, `memory_save_episode`, `memory_anxiety`, etc.).

Use MCP when:
- Your client doesn't support hooks or plugins (e.g., Claude Desktop)
- You want the SI to control when memory loads/saves happen
- You need in-session memory tools alongside either integration

MCP and hooks complement each other. The typical setup is hooks for automatic lifecycle + MCP for in-session operations.

## Migration Between Integrations

### OpenClaw to Claude Code

1. Remove the OpenClaw plugin:
   ```bash
   openclaw plugins uninstall kernle
   ```

2. Set up Claude Code hooks:
   ```bash
   kernle setup claude-code
   ```

3. Memory data stays in the same stack — no migration needed.

### Claude Code to OpenClaw

1. Remove hooks from `.claude/settings.json` (delete the `kernle hook` entries).

2. Install the OpenClaw plugin:
   ```bash
   cd kernle/integrations/openclaw
   npm install && npm run build
   openclaw plugins install ./integrations/openclaw
   ```

3. Memory data stays in the same stack — no migration needed.
