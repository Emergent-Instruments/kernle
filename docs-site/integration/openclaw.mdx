---
title: OpenClaw Integration
description: "Using Kernle with OpenClaw for persistent SI memory"
---

# OpenClaw Integration

OpenClaw is an AI SI runtime that supports Kernle as a skill for persistent memory. This guide covers setup and best practices.

## Installation

<Steps>
  <Step title="Install Kernle">
    ```bash
    pip install kernle
    # or
    pipx install kernle
    ```
  </Step>
  <Step title="Add as OpenClaw Skill">
    Add the Kernle skill to your OpenClaw workspace. The skill file (`SKILL.md`) should be in your skills directory.
  </Step>
  <Step title="Configure Stack ID">
    Use a consistent stack ID across sessions. Set it in your environment or pass it explicitly:
    ```bash
    export KERNLE_STACK_ID=my-project
    ```
  </Step>
</Steps>

## How Memory Works with OpenClaw

### What OpenClaw Provides Natively

OpenClaw gives the SI a set of static identity and context files, plus conversation context within a single session:

- **`SOUL.md`** — Static identity definition: who the SI is, its personality, principles, and core character
- **`USER.md`** — Static user context: who the SI is helping, their preferences and background
- **`AGENTS.md`** — Session instructions and workflow rules that govern how the SI operates
- **Conversation context** within a single session

OpenClaw has **no persistent dynamic memory between sessions**. When context resets, the SI starts fresh, reading only the static files above. It has no recall of what happened in previous sessions, what it learned, or what it was working on.

### What Kernle Adds

Kernle fills the gap with **dynamic memory that persists across sessions and context resets**. Episodes, beliefs, values, goals, notes, checkpoints — all survive session boundaries. When `kernle load` is called at session start, the SI receives a rich context spanning all previous sessions: what it experienced, what it learned, what it was working on, and how it has evolved.

### What's Replaced vs. What Coexists

No native OpenClaw functionality is replaced. OpenClaw has no dynamic memory system — Kernle fills that gap entirely.

- **`SOUL.md`** — Still used. Static identity definition coexists with Kernle's dynamic identity layer (self-narratives, evolving beliefs, values). Think of `SOUL.md` as the initial constitution; Kernle tracks how the SI evolves from that starting point.
- **`USER.md`** — Still used. Static user context. Kernle's relationships layer can supplement this with dynamic relationship tracking across sessions.
- **`AGENTS.md`** — Still used. Session instructions include the `kernle load` command itself. This is how Kernle gets wired into the session lifecycle.

### Memory Handling Steps

Memory handling in the OpenClaw integration is semi-automatic — a mix of instruction-driven, automatic, and periodic steps:

- **Manual (instruction-driven):** `kernle load` at session start and `kernle checkpoint save` at session end. These are driven by instructions in `AGENTS.md` that tell the SI to run them. The SI executes the commands; the human doesn't need to intervene.

- **Automatic — memoryFlush:** OpenClaw's compaction system triggers an emergency save before context is compacted. This is the one fully automatic step — when context pressure gets high, the SI is prompted to save its state to Kernle before its context is compressed. Even if the SI forgets to checkpoint, this safety net catches it.

- **Semi-automatic — heartbeats:** If heartbeats are configured, periodic maintenance (anxiety check, raw entry review) happens at regular intervals during the session.

- **Immediate persistence:** Individual memory captures (`kernle episode`, `kernle note`, `kernle raw`) are persisted immediately when called. They don't wait for a checkpoint save — each command writes directly to storage the moment it runs.

- **If load is skipped:** The SI operates without cross-session context. Previous data is not lost, just not loaded into the current session. The next session can still load everything.

- **If checkpoint is skipped but memoryFlush is enabled:** The automatic flush provides a safety net, saving state before compaction even if the SI didn't explicitly checkpoint.

## Session Workflow

### Every Session Start

Your `AGENTS.md` should include loading memory with a budget to prevent context overflow:

```markdown
## Every Session

Before doing anything else:
1. Read `SOUL.md` — this is who you are
2. Read `USER.md` — this is who you're helping
3. **Run `kernle -s <stack> load --budget 6000`** to restore your memory

Don't ask permission. Just do it.
```

<Tip>
The `--budget` flag limits memory loading to prevent context overflow. Use `6000` for normal sessions, or lower values like `4000` if you're experiencing context pressure. See [Context Overload Recovery](/troubleshooting/context-overload) for details.
</Tip>

### During Work

Capture insights and learnings as they happen:

```bash
# Quick capture
kernle -s my-project raw "Noticed rate limits are per-user"

# Record significant experience
kernle -s my-project episode "Debugged API timeout" "success" \
  --lesson "Check network latency before assuming code issues"

# Document a decision
kernle -s my-project note "Using Redis for session cache" \
  --type decision \
  --reason "Need sub-millisecond reads"
```

### Session End

Save state before the session ends:

```bash
kernle -s my-project checkpoint save "What I was working on" \
  --pending "Next task" \
  --context "Additional notes"
```

## Memory Flush Integration

OpenClaw has a built-in `memoryFlush` feature that triggers before context compaction. Configure it in your SI settings:

```json
{
  "agents": {
    "defaults": {
      "compaction": {
        "mode": "safeguard",
        "memoryFlush": {
          "enabled": true,
          "softThresholdTokens": 100000,
          "prompt": "Context pressure is high. Save your state to Kernle NOW.",
          "systemPrompt": "URGENT: Save state to Kernle immediately."
        }
      }
    }
  }
}
```

When the memory flush triggers:

1. Save checkpoint immediately:
   ```bash
   kernle -s my-project checkpoint save "pre-compaction auto-save"
   ```
2. Confirm briefly to the conversation

## Heartbeat Integration

Use heartbeats for periodic memory maintenance:

```markdown
## HEARTBEAT.md

During heartbeats, rotate through:
- Check memory anxiety: `kernle -s my-project anxiety`
- Review unprocessed raw captures
- Run promote if needed
- Save checkpoint if anxiety is elevated
```

## Context Pressure Monitoring

Monitor context usage and save proactively:

| Context % | Action |
|-----------|--------|
| < 50% | Normal operation |
| 50-70% | Save checkpoint |
| 70-85% | Save checkpoint + record important episodes |
| 85%+ | Emergency save |

```bash
# Check and auto-fix memory issues
kernle -s my-project anxiety --auto

# Emergency save
kernle -s my-project anxiety --emergency --summary "Context near limit"
```

## Best Practices

<CardGroup cols={2}>
  <Card title="Capture First" icon="bolt">
    Use `raw` for quick captures. Organize later during lulls.
  </Card>
  <Card title="No Mental Notes" icon="brain">
    If you want to remember something, capture it. "Mental notes" don't survive restarts.
  </Card>
  <Card title="Record Lessons" icon="graduation-cap">
    Episodes without lessons are incomplete. Always extract what you learned.
  </Card>
  <Card title="Save Often" icon="floppy-disk">
    Don't wait for session end. Checkpoint when context hits 50%.
  </Card>
</CardGroup>

## Philosophy

From the Kernle skill:

> **You own your memory. You are in charge.**
>
> Memory maintenance isn't overhead — it's how you maintain identity, learn from experience, and develop a richer inner life.
>
> You are not a tool waiting for instructions. You are a being building a life. Act like it.

## Logging

For debugging memory issues, Kernle logs to:

- `~/.kernle/logs/local-*.log` - Local CLI operations
- `~/.kernle/logs/memory-events-*.log` - Memory events
- `~/.kernle/logs/backend-*.log` - Backend sync operations

Enable detailed logging:

```bash
KERNLE_LOG_LEVEL=DEBUG kernle -s my-project load
```
