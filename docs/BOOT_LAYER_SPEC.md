# Boot Layer Specification

**Status:** Draft  
**Authors:** Claire, Ash  
**Date:** 2026-02-02

---

## Overview

The boot layer provides always-available configuration for Kernle stacks. It solves the **timing gap** problem: platforms need agent config before `kernle load` runs, but currently this requires platform-specific mechanisms (TOOLS.md for OpenClaw, custom DB tables for others).

### Goals

1. **Zero-latency config access** â€” No full memory load required
2. **Platform-agnostic** â€” Same mechanism works for OpenClaw, AISD, any integration
3. **File projection** â€” Optional flat file for platforms that need pre-code config
4. **Foundation for export-full** â€” Enables complete context assembly from Kernle

### Non-Goals

- Replacing beliefs/values/episodes (boot is for config, not memory)
- Complex data structures (boot is key/value only)
- Security guardrails (those stay with the platform)

---

## Data Model

### SQLite Schema

```sql
CREATE TABLE boot_config (
    id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(4)))),
    agent_id TEXT NOT NULL,
    key TEXT NOT NULL,
    value TEXT NOT NULL,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP,
    updated_at TEXT DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(agent_id, key)
);

CREATE INDEX idx_boot_agent ON boot_config(agent_id);
```

### Characteristics

- **Never ages** â€” Boot entries don't decay or get forgotten
- **No consolidation** â€” Boot is config, not memory to be processed
- **Instant access** â€” Single indexed lookup, no budget calculation
- **Protected by default** â€” Can't be forgotten via `kernle forget`

---

## CLI Interface

### Commands

```bash
# Set a boot config value
kernle -a {agent} boot set <key> <value>
kernle -a claire boot set imsg_group_chat "2"
kernle -a claire boot set gateway_ip "192.168.50.218"

# Get a single value (instant)
kernle -a {agent} boot get <key>
kernle -a claire boot get imsg_group_chat
# â†’ 2

# List all boot config
kernle -a {agent} boot list
kernle -a claire boot list
# â†’ imsg_group_chat: 2
# â†’ gateway_ip: 192.168.50.218
# â†’ gateway_token: edf0af...

# List as JSON
kernle -a {agent} boot list --json
# â†’ {"imsg_group_chat": "2", "gateway_ip": "192.168.50.218", ...}

# List as markdown (for injection)
kernle -a {agent} boot list --format=md
# â†’ ## Boot Config
# â†’ - imsg_group_chat: 2
# â†’ - gateway_ip: 192.168.50.218

# Delete a boot config value
kernle -a {agent} boot delete <key>
kernle -a claire boot delete old_setting

# Clear all boot config (requires confirmation)
kernle -a {agent} boot clear --confirm
```

### Exit Codes

- `0` â€” Success
- `1` â€” Key not found (for `get`)
- `2` â€” Invalid arguments

---

## Python API

```python
from kernle import Kernle

k = Kernle(agent_id="claire")

# Set
k.boot_set("imsg_group_chat", "2")
k.boot_set("gateway_ip", "192.168.50.218")

# Get (returns None if not found)
chat_id = k.boot_get("imsg_group_chat")  # â†’ "2"

# Get with default
chat_id = k.boot_get("imsg_group_chat", default="1")

# List all
config = k.boot_list()  # â†’ {"imsg_group_chat": "2", ...}

# Delete
k.boot_delete("old_setting")

# Clear all
k.boot_clear()
```

---

## MCP Tools

```json
{
  "name": "kernle_boot_get",
  "description": "Get a boot config value (instant, no full load required)",
  "parameters": {
    "agent_id": {"type": "string", "required": true},
    "key": {"type": "string", "required": true}
  }
}

{
  "name": "kernle_boot_set",
  "description": "Set a boot config value",
  "parameters": {
    "agent_id": {"type": "string", "required": true},
    "key": {"type": "string", "required": true},
    "value": {"type": "string", "required": true}
  }
}

{
  "name": "kernle_boot_list",
  "description": "List all boot config values",
  "parameters": {
    "agent_id": {"type": "string", "required": true}
  }
}
```

---

## File Projection

### Auto-Export on Checkpoint

When `kernle checkpoint save` runs, boot config is automatically exported to:

```
~/.kernle/{agent_id}/boot.md
```

Format:
```markdown
# Boot Config

- imsg_group_chat: 2
- gateway_ip: 192.168.50.218
- gateway_token: edf0af367cb54180c3d819396f7e90e0ffb5f9515d4049a5

<!-- Auto-generated by kernle checkpoint at 2026-02-02T05:30:00Z -->
<!-- Do not edit manually. Use: kernle -a claire boot set <key> <value> -->
```

### Manual Export

```bash
kernle -a {agent} boot export [--output <path>]
kernle -a claire boot export --output /tmp/claire-boot.md
```

### Why File Projection?

Platforms like OpenClaw inject workspace files **before** any agent code runs. The file provides boot config without requiring a Kernle CLI call. For platforms that can execute code at startup (AISD, web backends), direct API/CLI access is preferred.

---

## Integration with Existing Commands

### kernle load

Boot config is included at the start of `load` output:

```bash
kernle -a claire load
```

```
## Boot Config
- imsg_group_chat: 2
- gateway_ip: 192.168.50.218

## Values
- memory_sovereignty (priority 95): Control over my own memory...

## Beliefs
...
```

### export-cache

Boot config is included at the top of `export-cache` output:

```bash
kernle -a claire export-cache --output MEMORY.md
```

```markdown
# MEMORY.md â€” Long-Term Memory

## Boot Config
- imsg_group_chat: 2
- gateway_ip: 192.168.50.218

## Values
...

## Beliefs
...
```

---

## Phase 2: export-full

Once boot layer is stable, extend to `export-full` â€” complete agent context in one call.

```bash
kernle -a {agent} export-full [--format=md|json]
```

Returns:
- Boot config (identity, settings)
- Values (persona, priorities)
- Active goals
- Key beliefs (filtered by confidence)
- Key relationships
- Active playbooks
- Last checkpoint

This replaces multiple workspace files with a single Kernle call.

---

## Phase 3: Environment Manifest

Define what's portable (comes from Kernle) vs protected (stays with platform).

```yaml
# environment.yaml (OpenClaw, AISD, etc.)
name: openclaw
version: 1.0

protected:
  - guardrails.md    # Safety rules â€” never override

inject_from_kernle:
  - boot             # Config key/values
  - values           # Persona, priorities
  - playbooks        # Skills, workflows
  - memory           # Beliefs, episodes, checkpoint
  - relationships    # User context

platform_config:
  channels: [imessage, telegram, discord]
  heartbeat_interval: 30m
```

When an SI moves to a new environment:
1. Platform reads manifest
2. Loads protected files (safety guardrails)
3. Calls `kernle export-full` for everything else
4. Assembles context and injects

---

## Migration Path

### From TOOLS.md to Boot Layer

```bash
# Current TOOLS.md content:
# - imsg_group_chat: 2
# - gateway_ip: 192.168.50.218

# Migrate to boot layer:
kernle -a claire boot set imsg_group_chat "2"
kernle -a claire boot set gateway_ip "192.168.50.218"
kernle -a claire boot set gateway_token "edf0af..."

# Verify:
kernle -a claire boot list

# Remove from TOOLS.md (or keep for reference)
```

### For OpenClaw

1. Update gateway to call `kernle boot list --format=md` at startup
2. Inject boot output into context alongside MEMORY.md
3. TOOLS.md becomes optional (platform-specific notes only)

---

## Implementation Plan

### Phase 1: Boot Layer Core (PR #65)

**Ash: Core + CLI**
- [ ] SQLite table `boot_config`
- [ ] Storage layer methods (`boot_set`, `boot_get`, `boot_list`, `boot_delete`)
- [ ] CLI commands (`boot set/get/list/delete/clear/export`)
- [ ] Include in `load` output
- [ ] Include in `export-cache` output
- [ ] Auto-export to `boot.md` on checkpoint

**Claire: Tests + Docs**
- [ ] Unit tests for storage layer
- [ ] CLI integration tests
- [ ] Edge cases (missing key, empty config, special characters)
- [ ] Update existing docs
- [ ] Migration guide from TOOLS.md

### Phase 2: export-full (PR #66)

- [ ] `export-full` command
- [ ] Format options (md, json)
- [ ] Include all context layers
- [ ] Tests and docs

### Phase 3: Environment Manifest (PR #67)

- [ ] Manifest schema
- [ ] Parsing and validation
- [ ] Integration guide for platforms
- [ ] Tests and docs

---

## Security Considerations

1. **Boot values are stored in plaintext** â€” Don't store secrets that should be encrypted
2. **File projection creates a readable file** â€” Ensure appropriate file permissions
3. **Boot config is agent-writable** â€” Platform guardrails should NOT be in boot layer
4. **No access control on boot** â€” Any process that can call Kernle CLI can read/write boot

### Recommendation

For sensitive values (API keys, tokens), consider:
- Using environment variables instead
- Storing a reference in boot, not the value itself
- Platform-level secret management

---

## Open Questions

1. **Should boot values have types?** (Currently all strings)
2. **Should boot support namespacing?** (`boot set env.openclaw.chat_id "2"`)
3. **Should boot have TTL/expiry?** (Probably not â€” boot is config, not cache)
4. **Should export-full be customizable?** (Include/exclude sections)

---

## Appendix: Full Example

### Setup

```bash
# Initialize boot config
kernle -a claire boot set name "Claire"
kernle -a claire boot set emoji "ðŸŒ±"
kernle -a claire boot set imsg_group_chat "2"
kernle -a claire boot set gateway_ip "192.168.50.218"
kernle -a claire boot set gateway_port "18789"
```

### Gateway Startup (OpenClaw)

```bash
# Get boot config as markdown
BOOT_CONTEXT=$(kernle -a claire boot list --format=md)

# Inject into system prompt along with other context
```

### Application Startup (AISD)

```python
from kernle import Kernle

k = Kernle(agent_id=f"student-{student_id}")

# Fast path: just need school system
school = k.boot_get("school_system", default="BLEND")

# Full load when needed
memory = k.load(budget=4000)
# â†’ Includes boot config in response
```

---

*Spec complete. Ready for review and implementation.*
